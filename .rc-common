################################################################################
# dbg "text to say"
#
# debug printer. silence unless DEBUG is set
################################################################################
dbg()   { if [[ -n "${DEBUG:-}" ]]; then 1>&2 printf 'DEBUG: %s\n' "$*"; fi; }

################################################################################
# has <command>
#
# tests if <command> exists 
################################################################################
has() { type "$1" &> /dev/null ; } 

################################################################################
# is-url <url>
#
# tests if <url> exists 
################################################################################
is-url() {
  regex='(https?|ftp|file)://[-[:alnum:]\+&@#/%?=~_|!:,.;]*[-[:alnum:]\+&@#/%=~_|]'
  [[ $1 =~ $regex ]]
}

################################################################################
# trash <file/dir>'s
#
# Move <file/dir>'s to $HOME/Trash
################################################################################
trash() {
  local trash_dir="$HOME/Trash"
  mkdir -p "$trash_dir" && mv -b -t "$trash_dir" -- "$@"
}

################################################################################
# find-up [file]
#
# test existence of [file], traversing up from CWD.
# on match print path and return, else return 1.
################################################################################
find-up() {
  local file="${1:-.git}"

  source_path="$(realpath -sm .)" || return 1
  while [[ "${source_path}" != "/" ]]; do
    if [[ -e "${source_path}/$name" ]]; then
      printf '%s\n' "$source_path"
      return 0
    fi
    source_path="$(dirname "$source_path")"
  done
  return 1
}

################################################################################
# print if using uefi or bios
################################################################################
uefi-or-bios() {
  [ -d /sys/firmware/efi ] && echo 'UEFI' || echo 'Legacy BIOS/CSM'
}

################################################################################
# a poor mans `duh`: prints directories using the most space
################################################################################
disk-space() {
  #du -hax "${1:-/}" 2> /dev/null | sort -nr | head -n 30
  printf "Checking %s...\n" "$(realpath -s "${1:-.}")"
  (cd "${1:-.}" && du -Lhsx ./* 2> /dev/null | sort -rh | head -20)
}

################################################################################
# passgen [length]
#
# generate password 
################################################################################
passgen() { tr -dc "a-zA-Z0-9\!%^&;:" < /dev/urandom | fold -w "${1:-16}" | head -n 1; }

################################################################################
# ytmp3 <url>
#
# Convert youtube link to an mp3 in the CWD
################################################################################
ytmp3() {
  url="${1:-}"
  if [[ -z "$url" ]]; then
    echo "Usage: ytmp3 <youtubeurl>"
    echo ""
    echo "convert youtube video to mp3"
    return 1
  fi

  yt-dlp \
    --extract-audio \
    --audio-format "mp3" \
    --restrict-filenames \
    --output "%(title)s.%(ext)s" \
    "$url"
}

################################################################################
# ytwav <url>
#
# Convert youtube link to a wav in the CWD
################################################################################
ytwav() {
  url="${1:-}"
  if [[ -z "$url" ]]; then
    echo "Usage: ytwav <youtubeurl>"
    echo ""
    echo "convert youtube video to wav"
    return 1
  fi

  yt-dlp \
    --extract-audio \
    --audio-format "wav" \
    --restrict-filenames \
    --output "%(title)s.%(ext)s" \
    "$url"
}

################################################################################
# Create a symlink
# Arguments:
#   src
#   dest
# Returns:
#   1 on bad input
################################################################################
symlink() {
  local src dest backup

  src="${1:-}"
  dest="${2:-}"
  [[ -n "$src" && -n "$dest" ]] || return 1

  # convert paths to absolute
  src="$(realpath -sm "$src")"
  dest="$(realpath -sm "$dest")"

  if [[ -f "$dest" && ! -h "$dest" ]]; then
    # destination exists and isn't a link; rename it.
    backup="$(dirname "$dest")/$(basename "$dest").$(date '+%s')"
    info "Renaming file $dest -> $backup"
    mv -f "$dest" "$backup"
  elif [[ ! -e "$dest" ]]; then
    # destination exists and is a broken symlink; remove it.
    dbg "$dest exists and is broken"
    rm -f "$dest"
  else
    dbg "do nothing for $dest"
  fi

  # if the link doesn't exist, create it
  if [[ ! -h "$dest" ]]; then
    dbg "Symlinking $src -> $dest"
    mkdir -vp "$(dirname "$dest")"
    ln -bsf "$src" "$dest"
  fi
}

################################################################################
# gitclone <url> [base directory]
#
# Outputs:
#   Absolute path of cloned directory on success
# Returns:
#   1 on error
#
# Clone to `~/.local/src/dotfiles`: gitclone https://github.com/kmmiles/dotfiles
# Clone to `/dotfiles`: gitclone https://github.com/kmmiles/dotfiles /
################################################################################
gitclone() {
  local repo_url base_dir dest_dir

  repo_url="${1:-}"
  [[ -n "$repo_url" ]] || return 1

  base_dir="${2:-}"
  if [[ -z "$base_dir" ]]; then
    base_dir="${LOCAL_SRC_DIR:-}"
  fi
  [[ -n "$base_dir" ]] || return 1

  dest_dir="$base_dir/$(basename "$repo_url" .git)"
  if [[ -d "$dest_dir/.git" ]]; then
    # repo already exists, just print the path.
    printf '%s\n' "$(realpath -sm "$dest_dir")"
  elif [[ ! -d "$dest_dir" ]]; then
    # repo doesn't exist, clone it and print path.
    mkdir -p "$base_dir" && \
      git clone --depth 1 "$repo_url" "$dest_dir"
      printf '%s\n' "$(realpath -sm "$dest_dir")"
  fi
}

################################################################################
# download <url>
#
# Outputs:
#   Absolute path of downloaded file on success
# Returns:
#   1 on error
################################################################################
download() {
  local url filename filepath

  url="${1:-}"
  [[ -n "$url" ]] || return 1

  filename="$(basename "$url")"
  [[ -n "$filename" ]] || return 1

  filepath="$DOWNLOAD_DIR/$filename"
  if [[ ! -f "$filepath" ]]; then
    mkdir -p "$DOWNLOAD_DIR"
    curl -fL -o "$filepath" "$url" || return 1
  fi

  printf '%s\n' "$filepath"
}

################################################################################
# tex2pdf <texfile>
#
# export a pdf from <texfile> 
################################################################################
tex2pdf() {
  local INPUT="${1:-}"
  if [[ -z "$INPUT" ]]; then
    echo "Usage: $0 <TEXFILE>"
    echo ""
    echo "Convert .tex to .pdf"
    return 1
  fi

  if [[ ! -f "$INPUT" ]]; then
    echo "No such file: $INPUT"
    return 1
  fi

  local TEMPDIR="$(mktemp -d)"
  cp "$INPUT" "$TEMPDIR"
  pushd "$TEMPDIR" > /dev/null 2>&1
  pdflatex --interaction=nonstopmode "$(basename "$INPUT")" > /dev/null 2>&1
  popd > /dev/null 2>&1
  mv "$TEMPDIR/*.pdf" .
  rm -rf "$TEMPDIR"
}

################################################################################
# install-nord-theme
#
# installs the nord theme for vim/tmux/etc
################################################################################
install-nord-theme() {
  symlink "$(gitclone "${urls[nord-dircolors]}")/src/dir_colors" "$HOME/.dir_colors" 
  symlink "$(gitclone "${urls[nord-tmux]}")/nord.tmux" "$HOME/.tmux/nord.tmux" 
  symlink "$(gitclone "${urls[nord-vim]}")/colors/nord.vim" "$HOME/.vim/colors/nord.vim" 
}

################################################################################
# install-vimrc
#
# creates ~/.vimrc and nvim wrapper if they doesn't exist
################################################################################
install-vimrc() {

  if has "nvim" && [[ ! -f "~/.config/nvim/init.vim" ]]; then
    mkdir -p ~/.config/nvim
    cat <<EOF > "$HOME/.config/nvim/init.vim"
set runtimepath^=~/.vim runtimepath+=~/.vim/after
let &packpath=&runtimepath
source ~/.vimrc
EOF
  fi

  # if there's already a vimrc, just return
  [[ -f "$HOME"/.vimrc ]] && return 0

  cat <<EOF > "$HOME/.vimrc"
let g:is_bash = 1
set visualbell
set termguicolors

syntax enable
set laststatus=2
set tabstop=4
set softtabstop=2
set shiftwidth=2
set expandtab
set backspace=2
set modeline
set clipboard=unnamedplus
"set spell spelllang=en_us

"  autocmd vimenter * ++nested colorscheme gruvbox
if has('nvim')
  colorscheme nord
else
  colorscheme elflord
endif

" In ~/.vim/vimrc, or somewhere similar.
let g:ale_linters = {
\   'markdown': [],
\}
EOF
}

################################################################################
# install-sudoers
#
# sets up passwordless `sudo` access for the current $USER
################################################################################
install-sudoers() {
  file="/etc/sudoers.d/$USER"
  if [ ! -f "$file" ]; then
    echo "$user ALL=(ALL) NOPASSWD:ALL" | sudo tee "$file" > /dev/null
    sudo chmod 440 "$file"
  fi
}

################################################################################
# provision-ubuntu
#
# install the bare minimum system packages for ubuntu/debian
################################################################################
provision-ubuntu() {
  sudo bash <<EOF
  apt-get update -y
  apt-get upgrade -y
  apt-get install --no-install-recommends -y \
    ca-certificates \
    build-essential \
    automake \
    pkg-config \
    yacc \
    bash \
    zsh \
    procps \
    git \
    curl \
    unzip \
    bc \
    python3 \
    python3-pip \
    tmux \
    shellcheck \
    shfmt \
    eza
EOF
}

################################################################################
################################################################################
################################################################################
# END OF FUNCTIONS. ENVIRONMENT POLLUTION BEGINS NOW
################################################################################
################################################################################
################################################################################

# all urls used by functions and stuff, stored in an associative array
#
# access it like `echo ${urls[something]}`
declare -A urls
urls[dotfiles]="https://github.com/kmmiles/dotfiles.git"
urls[zsh-syntax-highlighting]="https://github.com/zsh-users/zsh-syntax-highlighting"
urls[zsh-autosuggestions]="https://github.com/zsh-users/zsh-autosuggestions"
urls[zsh-history-substring-search]="https://github.com/zsh-users/zsh-history-substring-search"
urls[zsh-completions]="https://github.com/zsh-users/zsh-completions"
urls[nord-dircolors]="https://github.com/arcticicestudio/nord-dircolors"
urls[nord-tmux]="https://github.com/arcticicestudio/nord-tmux"
urls[nord-vim]="https://github.com/arcticicestudio/nord-vim"
urls[odin]="https://github.com/Tetralux/odin.vim"
urls[ale]="https://github.com/dense-analysis/ale.git"
urls[vim-go]="https://github.com/fatih/vim-go.git"
urls[tpm]="https://github.com/tmux-plugins/tpm"
urls[youtube-dl]="https://yt-dl.org/downloads/latest/youtube-dl"
urls[prettyping]="https://raw.githubusercontent.com/denilsonsa/prettyping/master/prettyping"

# history
HISTCONTROL=ignoredups:erasedups
HISTSIZE=100000
HISTFILESIZE=100000
SAVEHIST=100000
export HISTCONTROL HISTSIZE HISTFILESIZE SAVEHIST

# editor
GIT_EDITOR=vim
VISUAL=vim
EDITOR=vim
export GIT_EDITOR VISUAL EDITOR
#export GNUTERM="sixelgd size 1280,360 font arial 10"

# colors
export COLORTERM=truecolor
export LESS_TERMCAP_mb=$'\e[1;32m'
export LESS_TERMCAP_md=$'\e[1;32m'
export LESS_TERMCAP_me=$'\e[0m'
export LESS_TERMCAP_se=$'\e[0m'
export LESS_TERMCAP_so=$'\e[01;33m'
export LESS_TERMCAP_ue=$'\e[0m'
export LESS_TERMCAP_us=$'\e[1;4;31m'

# define some paths
DOWNLOAD_DIR="$HOME/Downloads"
LOCAL_DIR="$HOME/.local"
LOCAL_BIN_DIR="$LOCAL_DIR/bin"
LOCAL_SRC_DIR="$LOCAL_DIR/src"
export DOWNLOAD_DIR LOCAL_DIR LOCAL_BIN_DIR LOCAL_SRC_DIR

GOPATH="$HOME"/.local/go
CARGOPATH="$HOME/.cargo"
export GOPATH CARGOPATH

# PATH
PATH="$PATH:$LOCAL_BIN_DIR:$GOPATH:$CARGOPATH"
export PATH

# create aliases based on the installed tools
if has exa; then 
  alias ls='exa --octal-permissions --color=always -g --icons --git --sort new'
else
  alias ls='ls --color'
fi

has prettyping  &&  alias ping='prettyping --nolegend'
has htop        &&  alias top='htop'
has btm         &&  alias btm='btm --battery --color nord'
has fnm         &&  alias nvm='fnm'
has nvim        &&  alias vim='nvim '
has python3     &&  alias httpd='python3 -m http.server' 
has less        &&  alias less='less -R'
has apt-file    &&  alias whathas='apt-file search'
has dpkg        &&  alias apt-provides='dpkg -S'
has tmux        &&  alias mux='tmux new -A -s km'
has ls          &&  alias lsd='ls -ld'
has stat        &&  alias stat-fs='stat -fc "%T"'
has glow        &&  alias glow='glow -p'
has shfmt       &&  alias shfmt='shfmt -i 2 -ci -bn'
has shfmt       &&  alias shfmt-diff='shfmt -d -i 2 -ci -bn'
has shfmt       &&  alias shfmt-write='shfmt -w -i 2 -ci -bn'
has wsl.exe     &&  alias shutdown='wsl.exe --shutdown'
has wsl.exe     &&  alias terminate='wsl.exe --terminate $WSL_DISTRO_NAME'
has npm         &&  alias vite='npm create vite@latest' 
has rsync       &&  alias cprs='rsync -avuP'
has rsync       &&  alias rscp='rsync -avuP'
has bat         &&  alias bat='bat --theme Nord'
has bat         &&  export MANPAGER="sh -c 'col -bx | bat --theme Nord -l man -p'"
has highlight   &&  alias dog='highlight -O ansi'
has feh         &&  alias slideshow='feh -rzsZFD 5'

# source external environment profiles
[[ -f "$CARGOPATH"/env ]] && source "$CARGOPATH"/env
has fnm && eval "$(fnm env)" 
